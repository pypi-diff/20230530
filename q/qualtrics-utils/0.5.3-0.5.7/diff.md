# Comparing `tmp/qualtrics_utils-0.5.3.tar.gz` & `tmp/qualtrics_utils-0.5.7.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "qualtrics_utils-0.5.3.tar", max compression
+gzip compressed data, was "qualtrics_utils-0.5.7.tar", max compression
```

## Comparing `qualtrics_utils-0.5.3.tar` & `qualtrics_utils-0.5.7.tar`

### file list

```diff
@@ -1,10 +1,9 @@
--rw-r--r--   0        0        0     1317 2023-05-15 17:53:52.951555 qualtrics_utils-0.5.3/README.md
--rw-r--r--   0        0        0      593 2023-05-15 18:05:16.795064 qualtrics_utils-0.5.3/pyproject.toml
--rw-r--r--   0        0        0        0 2023-05-15 17:54:25.042235 qualtrics_utils-0.5.3/qualtrics_utils/__init__.py
--rw-r--r--   0        0        0        0 2023-05-15 17:42:52.914230 qualtrics_utils-0.5.3/qualtrics_utils/codebook/__init__.py
--rw-r--r--   0        0        0     6989 2023-05-15 17:56:40.451923 qualtrics_utils-0.5.3/qualtrics_utils/codebook/generate.py
--rw-r--r--   0        0        0     3538 2023-05-15 18:03:33.886523 qualtrics_utils-0.5.3/qualtrics_utils/codebook/map_columns.py
--rw-r--r--   0        0        0     9221 2023-05-15 17:37:33.348189 qualtrics_utils-0.5.3/qualtrics_utils/survey.py
--rw-r--r--   0        0        0      494 2023-05-15 17:46:11.216385 qualtrics_utils-0.5.3/qualtrics_utils/utils.py
--rw-r--r--   0        0        0     2147 1970-01-01 00:00:00.000000 qualtrics_utils-0.5.3/setup.py
--rw-r--r--   0        0        0     2062 1970-01-01 00:00:00.000000 qualtrics_utils-0.5.3/PKG-INFO
+-rw-r--r--   0        0        0     1320 2023-05-15 18:07:27.778131 qualtrics_utils-0.5.7/README.md
+-rw-r--r--   0        0        0      611 2023-05-30 19:20:14.599478 qualtrics_utils-0.5.7/pyproject.toml
+-rw-r--r--   0        0        0      282 2023-05-30 19:18:28.891837 qualtrics_utils-0.5.7/qualtrics_utils/__init__.py
+-rw-r--r--   0        0        0        0 2023-05-15 17:42:52.914230 qualtrics_utils-0.5.7/qualtrics_utils/codebook/__init__.py
+-rw-r--r--   0        0        0     8037 2023-05-30 15:28:59.264868 qualtrics_utils-0.5.7/qualtrics_utils/codebook/generate.py
+-rw-r--r--   0        0        0     3520 2023-05-30 15:27:01.951352 qualtrics_utils-0.5.7/qualtrics_utils/codebook/map_columns.py
+-rw-r--r--   0        0        0     9590 2023-05-30 19:04:18.578923 qualtrics_utils-0.5.7/qualtrics_utils/survey.py
+-rw-r--r--   0        0        0     2425 2023-05-30 19:11:09.822025 qualtrics_utils-0.5.7/qualtrics_utils/utils.py
+-rw-r--r--   0        0        0     1978 1970-01-01 00:00:00.000000 qualtrics_utils-0.5.7/PKG-INFO
```

### Comparing `qualtrics_utils-0.5.3/README.md` & `qualtrics_utils-0.5.7/README.md`

 * *Files 8% similar despite different names*

```diff
@@ -28,16 +28,16 @@
 dictionaries.
 
 Example row:
 
 ```json
 {
         "question_number": "Q5.10",
-        "question_string": "What is your role at this school?"
-        "answer_choices": ...
+        "question_string": "What is your role at this school?",
+        "answer_choices": "..."
 },
 ```
 
 ### [`map_columns.py`](qualtrics_utils/codebook/map_codebook_columns.py)
 
 Takes a codebook mapping (generated by the above function) and creates conditional
 statements to map the question columns into valid Tableau or SQL code. Used to create a
```

### Comparing `qualtrics_utils-0.5.3/pyproject.toml` & `qualtrics_utils-0.5.7/pyproject.toml`

 * *Files 8% similar despite different names*

```diff
@@ -1,26 +1,27 @@
 [tool.poetry]
 name = "qualtrics-utils"
-version = "0.5.3"
+version = "0.5.7"
 description = "Utilities for qualtrics surveys."
 authors = ["Mike Babb <mike7400@gmail.com>"]
 readme = "README.md"
 keywords = ["qualtrics"]
 license = "MIT"
 repository = "https://github.com/mkbabb/qualtrics-utils"
 
 
 [tool.poetry.dependencies]
 python = "^3.10"
-pandas = "^2.0.1"
-numpy = "^1.24.3"
-googleapiutils2 = "^0.5.8"
-requests = "^2.30.0"
+pandas = "^2.0.2"
+requests = "^2.31.0"
 
 [tool.poetry.group.dev.dependencies]
+numpy = "^1.24.3"
+googleapiutils2 = "^0.5.9"
 mypy = "^1.3.0"
 black = "^23.3.0"
-types-requests = "^2.30.0.0"
+types-requests = "^2.31.0.1"
+pytest = "^7.3.1"
 
 [build-system]
 requires = ["poetry-core>=1.0.0"]
 build-backend = "poetry.core.masonry.api"
```

### Comparing `qualtrics_utils-0.5.3/qualtrics_utils/codebook/generate.py` & `qualtrics_utils-0.5.7/qualtrics_utils/codebook/generate.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,77 +1,71 @@
 import argparse
 import json
 import pathlib
 import re
 from typing import *
 
-from qualtrics_utils.utils import get_multiple, normalize_whitespace
+from qualtrics_utils.utils import normalize_whitespace
 
 RE_HTML_TAG = re.compile(r"<(.|\s)*?>")
 
 RE_SPACE = re.compile(r"&nbsp;")
 
 
 def normalize_html_string(s: str) -> str:
     s = re.sub(RE_HTML_TAG, "", s)
     s = re.sub(RE_SPACE, " ", s)
     s = normalize_whitespace(s)
     return s
 
 
-def map_questions(survey_element: dict) -> Optional[dict]:
-    PrimaryAttribute, Payload = (
-        survey_element["PrimaryAttribute"],
-        survey_element["Payload"],
+def map_questions(survey_element: dict[str, Any]) -> Optional[dict[str, Any]]:
+    PrimaryAttribute: str = survey_element["PrimaryAttribute"]
+    Payload: dict[str, Any] = survey_element["Payload"]
+
+    QuestionText: str = Payload["QuestionText"]
+    DataExportTag: str = Payload["DataExportTag"]
+    QuestionType: str = Payload["QuestionType"]
+    QuestionDescription: str = Payload["QuestionDescription"]
+
+    Choices: Optional[dict[str, Any]] = Payload.get("Choices")
+    ChoiceOrder: Optional[list[str]] = Payload.get("ChoiceOrder")
+
+    if Choices is not None and ChoiceOrder is not None:
+        ChoiceOrder = [str(i) for i in ChoiceOrder]
+        Choices = {key: Choices[key] for key in ChoiceOrder}
+
+    Selector: Optional[str] = Payload.get("Selector")
+    RecodeValues: dict[str, str] = Payload.get("RecodeValues", {})
+
+    Answers: Optional[dict[str, Any]] = Payload.get("Answers")
+    ChoiceDataExportTags: Optional[dict[str, str] | bool] = Payload.get(
+        "ChoiceDataExportTags"
     )
-    (
-        QuestionText,
-        DataExportTag,
-        QuestionType,
-        QuestionDescription,
-        Choices,
-        ChoiceOrder,
-        Selector,
-        RecodeValues,
-        Answers,
-        ChoiceDataExportTags,
-    ) = get_multiple(
-        Payload,
-        "QuestionText",
-        "DataExportTag",
-        "QuestionType",
-        "QuestionDescription",
-        "Choices",
-        "ChoiceOrder",
-        "Selector",
-        "RecodeValues",
-        "Answers",
-        "ChoiceDataExportTags",
-    ).values()
 
-    root_q_num = DataExportTag
-    root_q_str = QuestionText
+    root_q_num: str = DataExportTag
+    root_q_str: str = QuestionText
 
-    map_recode_values: Callable[[str], str] = (
-        lambda key: RecodeValues.get(key, key) if RecodeValues is not None else key
-    )
-
-    merge_a_choices: Callable[[dict, dict], list[dict]] = lambda a_choices, questions: [
-        {
-            **value,
-            "answer_choices": a_choices,
-        }
-        for _, value in questions.items()
-    ]
+    def merge_a_choices(
+        a_choices: dict[str, str], questions: dict[str, dict[str, Any]]
+    ) -> list[dict[str, Any]]:
+        """Merge answer choices into questions."""
+        return [
+            {
+                **value,
+                "answer_choices": a_choices,
+            }
+            for _, value in questions.items()
+        ]
 
     def create_question(
         q_num: str,
         q_str: str,
-        a_choices: Optional[dict] = None,
-    ) -> dict:
+        a_choices: Optional[dict[str, str]] = None,
+    ) -> dict[str, Any]:
         """A question object is a question number, question string, and an optional series of
         answer choices. We collate and normalize all three here.
 
         Qualtrics preserves the raw HTML in both question string and answer choice string,
         so we strip that away here.
         """
         out = {
@@ -79,139 +73,154 @@
             "question_string": q_str,
         }
         if a_choices is not None:
             return {**out, "answer_choices": a_choices}
         else:
             return out
 
-    def explode_question_number() -> dict:
+    def explode_question_number() -> dict[str, dict[str, Any]]:
         """If we have choices to pick from, we map those choices to question numbers.
         If a question number is found in the ChoiceDataExportTags object, that takes
         precedence, so we map it to that number."""
         questions = {}
+        if Choices is None or ChoiceOrder is None:
+            questions["1"] = create_question(root_q_num, root_q_str)
+            return questions
 
-        if isinstance(Choices, dict):
-            for key in ChoiceOrder:
-                key = str(key)
-                value = Choices[key]
+        # sort Choices by ChoiceOrder:
 
-                q_str = f"{root_q_str} - {value['Display']}"
+        for key, value in Choices.items():
+            sub_q_num = RecodeValues.get(key, key)
+            q_num = f"{root_q_num}_{sub_q_num}"
 
-                sub_q_num = map_recode_values(key)
-                q_num = f"{root_q_num}_{sub_q_num}"
+            value = Choices[key]
+            q_str = value["Display"]
 
-                if isinstance(ChoiceDataExportTags, dict):
-                    q_num = ChoiceDataExportTags.get(key, q_num)
+            if isinstance(ChoiceDataExportTags, dict):
+                q_num = ChoiceDataExportTags.get(key, q_num)
 
-                if QuestionType != "TE" and value.get("TextEntry") is not None:
-                    questions[key] = create_question(q_num, q_str)
+            if QuestionType != "TE" and value.get("TextEntry") is not None:
+                questions[key] = create_question(q_num, q_str)
 
-                    q_num += "_TEXT"
-                    key += "_TEXT"
+                q_num += "_TEXT"
+                key += "_TEXT"
 
-                    questions[key] = create_question(q_num, q_str)
-                else:
-                    questions[key] = create_question(q_num, q_str)
-        else:
-            questions["1"] = create_question(root_q_num, root_q_str)
+                questions[key] = create_question(q_num, q_str)
+            else:
+                questions[key] = create_question(q_num, q_str)
 
         return questions
 
-    if QuestionType == "Matrix":
-        """A 2-d matrix option has one column of questions, then a series of columns as answers.
-        For each question in the question column, we merge the answer choices, creating the final 2-d
-        result.
-
-        Example in 2-d form:
-            a0  a1  a2
-        q0  00  00  00
-        q1  00  00  00
-
-        Then as a pseudo-dict:
-
-        q0: {a0: 00, a1: 00, a2: 00}
-        q1: {a0: 00, a1: 00, a2: 00}
-        """
-        a_choices = {
-            map_recode_values(key): value["Display"] for key, value in Answers.items()
-        }
-        questions = explode_question_number()
-
-        return merge_a_choices(a_choices, questions)
-    # Multiple choice
-    elif QuestionType == "MC":
-        # Single answer
-        if Selector == "DL" or Selector == "SAVR":
+    def process_question() -> Optional[list[dict[str, Any]]]:
+        if QuestionType == "Matrix":
+            """A 2-d matrix option has one column of questions, then a series of columns as answers.
+            For each question in the question column, we merge the answer choices, creating the final 2-d
+            result.
+
+            Example in 2-d form:
+                a0  a1  a2
+            q0  00  00  00
+            q1  00  00  00
+
+            Then as a pseudo-dict:
+
+            q0: {a0: 00, a1: 00, a2: 00}
+            q1: {a0: 00, a1: 00, a2: 00}
+            """
             a_choices = {
-                map_recode_values(key): value["Display"]
-                for key, value in Choices.items()
+                RecodeValues.get(key, key): value["Display"]
+                for key, value in Answers.items()  # type: ignore
             }
-            return [create_question(root_q_num, root_q_str, a_choices)]
-        # Multiple answer, which creates a sort of 2-d matrix.
-        elif Selector == "MAVR":
-            a_choices = {"-1": "Not Selected", "1": "Selected", "Null": "Not Shown"}
             questions = explode_question_number()
             return merge_a_choices(a_choices, questions)
-        else:
-            return None
-    # Text entry, so no answer choices here.
-    elif QuestionType == "TE":
-        questions = explode_question_number()
-        return list(questions.values())
-    else:
+        # Multiple choice
+        elif QuestionType == "MC":
+            # Single answer
+            if Selector == "DL" or Selector == "SAVR":
+                a_choices = {
+                    RecodeValues.get(key, key): value["Display"]
+                    for key, value in Choices.items()  # type: ignore
+                }
+                return [create_question(root_q_num, root_q_str, a_choices)]
+            # Multiple answer, which creates a sort-of 2-d matrix.
+            elif Selector == "MAVR":
+                a_choices = {"-1": "Not Selected", "1": "Selected", "Null": "Not Shown"}
+                questions = explode_question_number()
+                return merge_a_choices(a_choices, questions)
+        # Text entry, so no answer choices here.
+        elif QuestionType == "TE":
+            questions = explode_question_number()
+            return list(questions.values())
+
         return None
 
+    return {
+        "question_number": root_q_num,
+        "question_string": root_q_str,
+        "question_type": QuestionType,
+        "questions": process_question(),
+    }
 
-def format_codebook(codebook: list[dict]) -> list[dict]:
-    """Format the codebook to be more readable.
-    Sorts the codebook by question number, and normalizes the HTML
-    in the question string and answer choices."""
 
-    def codebook_key(question: dict) -> float:
-        try:
-            question_number = question["question_number"]
-            return float(question_number.split("Q")[1])
-        except:
-            return float("inf")
-
-    codebook = sorted(codebook, key=codebook_key)
-
-    for question in codebook:
-        q_str, a_choices = (
-            question.get("question_string", ""),
-            question.get("answer_choices"),
-        )
+def format_codebook(codebook: list[dict[str, Any]]) -> list[dict[str, Any]]:
+    """Formats the codebook to be more readable.
 
-        question["question_string"] = normalize_html_string(q_str)
+    Sorts by question number, and then normalizes the HTML
+    in the question string and answer choices."""
 
-        if a_choices is not None:
-            a_choices = {
-                key: normalize_html_string(value) for key, value in a_choices.items()
-            }
-            question["answer_choices"] = a_choices
+    # sort by question number
+    codebook.sort(key=lambda x: float(str(x["question_number"]).lstrip("Q")))
+
+    for root_question in codebook:
+        root_q_str = root_question["question_string"]
+        root_question["question_string"] = normalize_html_string(root_q_str)
+
+        if root_question["questions"] is None:
+            continue
+
+        for question in root_question["questions"]:
+            q_str, a_choices = (
+                question.get("question_string", ""),
+                question.get("answer_choices"),
+            )
+            question["question_string"] = normalize_html_string(q_str)
+
+            if a_choices is not None:
+                a_choices = {
+                    key: normalize_html_string(value)
+                    for key, value in a_choices.items()
+                }
+                question["answer_choices"] = a_choices
 
     return codebook
 
 
-def generate_codebook(filepath: pathlib.Path) -> list[dict]:
-    """Generate a codebook from a Qualtrics .qsf file."""
-    codebook: list[dict] = []
+def generate_codebook(filepath: pathlib.Path) -> list[dict[str, Any]]:
+    """Generates a codebook from a Qualtrics .qsf file.
+
+    For more information on .qsf files, see:
+    https://api.qualtrics.com/docs/qsf
+
+    Args:
+        filepath (pathlib.Path): The path to the .qsf file.
+    """
+    codebook: list[dict[str, Any]] = []
 
     with open(filepath, "r") as file:
         qsf_json = json.load(file)
 
         SurveyElements = qsf_json["SurveyElements"]
 
         for element in SurveyElements:
             Element = element["Element"]
 
             if Element == "SQ":
                 questions = map_questions(element)
                 if questions is not None:
-                    codebook.extend(questions)
+                    codebook.append(questions)
 
     codebook = format_codebook(codebook)
 
     return codebook
 
 
 def main() -> None:
@@ -220,15 +229,15 @@
     args = parser.parse_args()
 
     filepath = args.input
 
     if filepath.suffix != ".qsf":
         raise ValueError("Please input a valid .qsf file.")
 
-    out_path = filepath.parent / f"{filepath.stem}-codebook"
+    out_path = filepath.parent / f"{filepath.stem}-codebook.json"
 
     codebook = generate_codebook(filepath)
 
     with open(out_path, "w") as file:
         json.dump(codebook, file, indent=4)
```

### Comparing `qualtrics_utils-0.5.3/qualtrics_utils/codebook/map_columns.py` & `qualtrics_utils-0.5.7/qualtrics_utils/codebook/map_columns.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 import argparse
 import json
 import pathlib
 from typing import *
 
 from qualtrics_utils.codebook.generate import generate_codebook
-from qualtrics_utils.utils import normalize_whitespace, quote_value
+from qualtrics_utils.utils import normalize_html, quote_value
 
 GENERATOR_TYPES = ["tableau", "sql"]
 
 
 def sql_qualtrics_map_func(mapping: dict) -> dict:
     question_number, question_string, answer_choices = (
         mapping["question_number"],
@@ -29,15 +29,15 @@
     mapping = key_mapping.get("mapping", {})
 
     s = "CASE\n"
 
     for sub_key, sub_value in mapping.items():
         sub_key, sub_value = (
             quote_value(sub_key, '"'),
-            quote_value(normalize_whitespace(sub_value), '"'),
+            quote_value(normalize_html(sub_value), '"'),
         )
         s += f"\tWHEN {key} = {sub_key} THEN {sub_value}\n"
 
     s += f"END AS {alias}"
     return key, s
 
 
@@ -55,15 +55,15 @@
 def generate_tableau(key_mapping: dict) -> Tuple[str, str]:
     key = key_mapping.get("key", "")
     mapping = key_mapping.get("mapping", {})
 
     s = ""
     for n, (sub_key, sub_value) in enumerate(mapping.items()):
         sub_key = sub_key if str(sub_key).isnumeric() else quote_value(sub_key, "'")
-        sub_value = quote_value(normalize_whitespace(sub_value), "'")
+        sub_value = quote_value(normalize_html(sub_value), "'")
 
         s += "ELSE" if n > 0 else ""
         s += f"IF [{key}] == {sub_key} THEN "
         s += f"{sub_value} "
 
     s += f"END"
     return key, s
```

### Comparing `qualtrics_utils-0.5.3/qualtrics_utils/survey.py` & `qualtrics_utils-0.5.7/qualtrics_utils/survey.py`

 * *Files 2% similar despite different names*

```diff
@@ -56,29 +56,31 @@
 
         payload = {
             "format": format,  # format of the exported file
             "useLabels": True,  # use labels instead of numerical values
             "breakoutSets": True,  # include breakout sets
             "seenUnansweredRecode": -1,  # recode seen but unanswered questions as -1
             "multiselectSeenUnansweredRecode": -1,  # recode multiselect seen but unanswered questions as -1
-            "allowContinuation": True,  # allow continuation of export via continuationToken
+            "allowContinuation": True
+            and continuationToken
+            is None,  # allow continuation of export via continuationToken
         }
         if continuationToken:
             payload["continuationToken"] = continuationToken
 
         r = requests.post(
             response_export_url,
             json=payload,
             headers=HEADERS,
         )
 
         if r.status_code != 200:
             return None
         else:
-            return r.json() # type: ignore
+            return r.json()  # type: ignore
 
     def _response_export_progress(
         self, surveyId: str, exportProgressId: str
     ) -> dict[str, Any] | None:
         progress_url = self._make_api_url(
             "{surveyId}/export-responses/{exportProgressId}",
             surveyId=surveyId,
@@ -161,20 +163,21 @@
         )
 
         r = requests.get(response_url, headers=HEADERS)
 
         if r.status_code != 200:
             return None
         else:
-            return r.json() # type: ignore
+            return r.json()  # type: ignore
 
     def get_responses_df(
         self,
         surveyId: str,
         continuationToken: Optional[str] = None,
+        filter_preview: bool = True,
         *args: Any,
         **kwargs: Any,
     ) -> ExportedFile[pd.DataFrame] | None:
         """Get responses from a survey by surveyId.
         Outputs a pandas DataFrame, with the index set to the ResponseId.
 
         All blank values therein are replaced with pd.NA.,
@@ -193,25 +196,33 @@
             surveyId=surveyId, continuationToken=continuationToken
         )
         if raw_data is None:
             return None
 
         with zipfile.ZipFile(BytesIO(raw_data.data)) as data:
             with data.open(data.filelist[0]) as f:
-                new_df: pd.DataFrame = pd.read_csv(f, skiprows=[1, 2], *args, **kwargs)
+                new_df_reader = pd.read_csv(
+                    f, skiprows=[1, 2], *args, **kwargs, iterator=True
+                )
+                new_df = pd.concat(new_df_reader, ignore_index=True)
                 new_df.set_index("ResponseId", inplace=True)
-                new_df = new_df.replace(r"^\s*$", pd.NA, regex=True)
+
+                new_df.replace([r"^\s*$", "-1", -1], pd.NA, regex=True, inplace=True)
+
                 new_df = new_df.astype(
                     {
                         col: "object"
                         for col in new_df.columns
                         if new_df[col].isna().all()
                     }
                 )
 
+                if filter_preview and "Status" in new_df.columns:
+                    new_df = new_df[new_df["Status"] != "Survey Preview"]
+
                 return ExportedFile(
                     fileId=raw_data.fileId,
                     continuationToken=raw_data.continuationToken,
                     data=new_df,
                 )
 
     def get_survey_schema(self, surveyId: str) -> dict[str, Any] | None:
@@ -222,15 +233,15 @@
         """
         schema_url = self._make_api_url("{surveyId}", surveyId=surveyId)
         r = requests.get(schema_url, headers=HEADERS)
 
         if r.status_code != 200:
             return None
         else:
-            return r.json() # type: ignore
+            return r.json()  # type: ignore
 
 
 # import numpy as np
 # from sqlalchemy import (
 #     Boolean,
 #     Column,
 #     DateTime,
```

### Comparing `qualtrics_utils-0.5.3/setup.py` & `qualtrics_utils-0.5.7/PKG-INFO`

 * *Files 26% similar despite different names*

```diff
@@ -1,33 +1,65 @@
-# -*- coding: utf-8 -*-
-from setuptools import setup
+Metadata-Version: 2.1
+Name: qualtrics-utils
+Version: 0.5.7
+Summary: Utilities for qualtrics surveys.
+Home-page: https://github.com/mkbabb/qualtrics-utils
+License: MIT
+Keywords: qualtrics
+Author: Mike Babb
+Author-email: mike7400@gmail.com
+Requires-Python: >=3.10,<4.0
+Classifier: License :: OSI Approved :: MIT License
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Requires-Dist: pandas (>=2.0.2,<3.0.0)
+Requires-Dist: requests (>=2.31.0,<3.0.0)
+Project-URL: Repository, https://github.com/mkbabb/qualtrics-utils
+Description-Content-Type: text/markdown
+
+# qualtrics-utils
+
+Utilities for qualtrics surveys. Get survey responses, generate codebooks, & c.
+
+## [`surveys`](qualtrics_utils/surveys.py)
+
+Module to interact with Qualtrics surveys.
+
+Example (get a survey's responses, convert to a pandas DataFrame):
+
+```python
+from qualtrics_utils.survey import Surveys
+
+qs = Surveys(api_token=QUALTRICS_API_TOKEN)
+
+exported_file = qs.get_responses_df(
+    surveyId=SURVEY_ID, parse_dates=["StartDate", "EndDate"]
+)
+df = exported_file.data
+```
+
+## Codebook mapping
+
+### [`generate.py`](qualtrics_utils/codebook/generate_codebook.py)
+
+Takes the exported `.qsf` file from Qualtrics and generates a codebook mapping question
+IDs to question text and answer choices. The output is a JSON file containing a list of
+dictionaries.
+
+Example row:
+
+```json
+{
+        "question_number": "Q5.10",
+        "question_string": "What is your role at this school?",
+        "answer_choices": "..."
+},
+```
+
+### [`map_columns.py`](qualtrics_utils/codebook/map_codebook_columns.py)
+
+Takes a codebook mapping (generated by the above function) and creates conditional
+statements to map the question columns into valid Tableau or SQL code. Used to create a
+singular question column in the above formats when there are multiple questions in a
+single question block (e.g. multiple Likert scale questions).
 
-packages = \
-['qualtrics_utils', 'qualtrics_utils.codebook']
-
-package_data = \
-{'': ['*']}
-
-install_requires = \
-['googleapiutils2>=0.5.8,<0.6.0',
- 'numpy>=1.24.3,<2.0.0',
- 'pandas>=2.0.1,<3.0.0',
- 'requests>=2.30.0,<3.0.0']
-
-setup_kwargs = {
-    'name': 'qualtrics-utils',
-    'version': '0.5.3',
-    'description': 'Utilities for qualtrics surveys.',
-    'long_description': '# qualtrics-utils\n\nUtilities for qualtrics surveys. Get survey responses, generate codebooks, & c.\n\n## [`surveys`](qualtrics_utils/surveys.py)\n\nModule to interact with Qualtrics surveys.\n\nExample (get a survey\'s responses, convert to a pandas DataFrame):\n\n```python\nfrom qualtrics_utils.survey import Surveys\n\nqs = Surveys(api_token=QUALTRICS_API_TOKEN)\n\nexported_file = qs.get_responses_df(\n    surveyId=SURVEY_ID, parse_dates=["StartDate", "EndDate"]\n)\ndf = exported_file.data\n```\n\n## Codebook mapping\n\n### [`generate.py`](qualtrics_utils/codebook/generate_codebook.py)\n\nTakes the exported `.qsf` file from Qualtrics and generates a codebook mapping question\nIDs to question text and answer choices. The output is a JSON file containing a list of\ndictionaries.\n\nExample row:\n\n```json\n{\n        "question_number": "Q5.10",\n        "question_string": "What is your role at this school?"\n        "answer_choices": ...\n},\n```\n\n### [`map_columns.py`](qualtrics_utils/codebook/map_codebook_columns.py)\n\nTakes a codebook mapping (generated by the above function) and creates conditional\nstatements to map the question columns into valid Tableau or SQL code. Used to create a\nsingular question column in the above formats when there are multiple questions in a\nsingle question block (e.g. multiple Likert scale questions).\n',
-    'author': 'Mike Babb',
-    'author_email': 'mike7400@gmail.com',
-    'maintainer': 'None',
-    'maintainer_email': 'None',
-    'url': 'https://github.com/mkbabb/qualtrics-utils',
-    'packages': packages,
-    'package_data': package_data,
-    'install_requires': install_requires,
-    'python_requires': '>=3.10,<4.0',
-}
-
-
-setup(**setup_kwargs)
```

