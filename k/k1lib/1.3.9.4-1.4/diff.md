# Comparing `tmp/k1lib-1.3.9.4-py3-none-any.whl.zip` & `tmp/k1lib-1.4-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,26 +1,26 @@
-Zip file size: 2548052 bytes, number of entries: 84
--rw-rw-r--  2.0 unx     1435 b- defN 23-Feb-08 00:13 k1lib/__init__.py
--rw-rw-r--  2.0 unx    53798 b- defN 23-May-25 22:28 k1lib/_baseClasses.py
+Zip file size: 2550571 bytes, number of entries: 84
+-rw-rw-r--  2.0 unx     1441 b- defN 23-May-26 17:16 k1lib/__init__.py
+-rw-rw-r--  2.0 unx    53938 b- defN 23-May-30 01:38 k1lib/_baseClasses.py
 -rw-rw-r--  2.0 unx    13494 b- defN 23-May-05 13:41 k1lib/_basics.py
 -rw-rw-r--  2.0 unx     4908 b- defN 23-May-08 18:53 k1lib/_context.py
 -rw-rw-r--  2.0 unx     2866 b- defN 22-Jul-20 04:30 k1lib/_higher.py
 -rw-rw-r--  2.0 unx      948 b- defN 22-Sep-21 23:54 k1lib/_k1a.py
 -rw-rw-r--  2.0 unx    11646 b- defN 23-Jan-14 15:37 k1lib/_learner.py
 -rw-rw-r--  2.0 unx    21467 b- defN 23-May-16 05:55 k1lib/_monkey.py
 -rw-rw-r--  2.0 unx     3571 b- defN 21-Nov-04 18:35 k1lib/_perlin.py
 -rw-rw-r--  2.0 unx    13377 b- defN 21-Dec-29 02:58 k1lib/eqn.py
--rw-rw-r--  2.0 unx     6850 b- defN 23-May-26 17:04 k1lib/fmt.py
+-rw-rw-r--  2.0 unx     7343 b- defN 23-May-30 07:52 k1lib/fmt.py
 -rw-rw-r--  2.0 unx     6398 b- defN 22-Sep-29 08:23 k1lib/graphEqn.py
 -rw-rw-r--  2.0 unx     2750 b- defN 23-May-24 23:19 k1lib/imports.py
 -rw-rw-r--  2.0 unx     3107 b- defN 22-Oct-26 20:43 k1lib/knn.py
 -rw-rw-r--  2.0 unx     3564 b- defN 23-Jan-25 02:48 k1lib/p5.py
 -rw-rw-r--  2.0 unx     8077 b- defN 22-May-06 21:09 k1lib/schedule.py
 -rw-rw-r--  2.0 unx    17767 b- defN 22-Sep-29 07:48 k1lib/selector.py
--rw-rw-r--  2.0 unx    16718 b- defN 23-May-05 13:50 k1lib/viz.py
+-rw-rw-r--  2.0 unx    17201 b- defN 23-May-30 01:38 k1lib/viz.py
 -rw-rw-r--  2.0 unx        0 b- defN 21-Aug-11 18:19 k1lib/_hidden/__init__.py
 -rw-rw-r--  2.0 unx       79 b- defN 21-Aug-11 18:19 k1lib/_hidden/hiddenFile.py
 -rw-rw-r--  2.0 unx      615 b- defN 21-Oct-24 23:32 k1lib/_mo/__init__.py
 -rw-rw-r--  2.0 unx    13464 b- defN 21-Nov-18 02:16 k1lib/_mo/atom.py
 -rw-rw-r--  2.0 unx     9629 b- defN 21-Nov-14 07:12 k1lib/_mo/parseM.py
 -rw-rw-r--  2.0 unx     2471 b- defN 21-Oct-20 20:39 k1lib/_mo/substance.py
 -rw-rw-r--  2.0 unx     9067 b- defN 22-Sep-29 08:06 k1lib/_mo/system.py
@@ -43,27 +43,27 @@
 -rw-rw-r--  2.0 unx     3465 b- defN 22-Nov-27 08:16 k1lib/callbacks/lossFunctions/shorts.py
 -rw-rw-r--  2.0 unx       45 b- defN 21-Aug-11 18:19 k1lib/callbacks/profilers/__init__.py
 -rw-rw-r--  2.0 unx     5054 b- defN 22-May-15 09:01 k1lib/callbacks/profilers/computation.py
 -rw-rw-r--  2.0 unx     2319 b- defN 22-May-15 08:59 k1lib/callbacks/profilers/io.py
 -rw-rw-r--  2.0 unx     4419 b- defN 22-May-15 09:00 k1lib/callbacks/profilers/memory.py
 -rw-rw-r--  2.0 unx     4215 b- defN 22-May-15 09:03 k1lib/callbacks/profilers/time.py
 -rw-rw-r--  2.0 unx      925 b- defN 22-Nov-16 09:22 k1lib/cli/__init__.py
--rw-rw-r--  2.0 unx    19109 b- defN 23-May-25 22:43 k1lib/cli/_applyCl.py
+-rw-rw-r--  2.0 unx    19145 b- defN 23-May-30 06:49 k1lib/cli/_applyCl.py
 -rw-rw-r--  2.0 unx     8308 b- defN 22-Nov-27 07:16 k1lib/cli/bio.py
 -rw-rw-r--  2.0 unx     4033 b- defN 23-Jan-25 02:02 k1lib/cli/cif.py
 -rw-rw-r--  2.0 unx    19321 b- defN 23-May-17 19:01 k1lib/cli/conv.py
--rw-rw-r--  2.0 unx    28497 b- defN 23-May-25 15:35 k1lib/cli/filt.py
+-rw-rw-r--  2.0 unx    29718 b- defN 23-May-29 22:41 k1lib/cli/filt.py
 -rw-rw-r--  2.0 unx     6672 b- defN 23-Jan-25 02:02 k1lib/cli/gb.py
 -rw-rw-r--  2.0 unx     6348 b- defN 23-Apr-05 15:10 k1lib/cli/grep.py
--rw-rw-r--  2.0 unx    19315 b- defN 23-May-25 22:37 k1lib/cli/init.py
--rw-rw-r--  2.0 unx    32645 b- defN 23-May-25 00:37 k1lib/cli/inp.py
+-rw-rw-r--  2.0 unx    19694 b- defN 23-May-30 01:25 k1lib/cli/init.py
+-rw-rw-r--  2.0 unx    36178 b- defN 23-May-30 02:01 k1lib/cli/inp.py
 -rw-rw-r--  2.0 unx      623 b- defN 22-Jun-22 10:43 k1lib/cli/kcsv.py
 -rw-rw-r--  2.0 unx     4819 b- defN 22-Aug-11 20:44 k1lib/cli/kxml.py
 -rw-rw-r--  2.0 unx     1915 b- defN 21-Nov-12 16:48 k1lib/cli/mgi.py
--rw-rw-r--  2.0 unx    64689 b- defN 23-May-26 16:48 k1lib/cli/modifier.py
+-rw-rw-r--  2.0 unx    65959 b- defN 23-May-26 22:00 k1lib/cli/modifier.py
 -rw-rw-r--  2.0 unx      694 b- defN 22-Nov-27 07:17 k1lib/cli/mol.py
 -rw-rw-r--  2.0 unx     4038 b- defN 23-May-09 15:53 k1lib/cli/nb.py
 -rw-rw-r--  2.0 unx     3530 b- defN 22-Aug-16 15:08 k1lib/cli/optimizations.py
 -rw-rw-r--  2.0 unx    12118 b- defN 23-May-22 17:09 k1lib/cli/output.py
 -rw-rw-r--  2.0 unx     2394 b- defN 23-Jan-25 02:03 k1lib/cli/sam.py
 -rw-rw-r--  2.0 unx    49390 b- defN 23-May-19 19:21 k1lib/cli/structural.py
 -rw-rw-r--  2.0 unx    10399 b- defN 22-Aug-05 01:15 k1lib/cli/trace.py
@@ -71,16 +71,16 @@
 -rw-rw-r--  2.0 unx    21101 b- defN 23-May-17 16:57 k1lib/cli/utils.py
 -rw-rw-r--  2.0 unx       20 b- defN 23-Jan-19 22:00 k1lib/k1ui/__init__.py
 -rw-rw-r--  2.0 unx    61803 b- defN 23-Feb-10 12:10 k1lib/k1ui/main.py
 -rw-rw-r--  2.0 unx       20 b- defN 22-Sep-16 01:12 k1lib/serve/__init__.py
 -rw-rw-r--  2.0 unx    10361 b- defN 23-May-05 16:49 k1lib/serve/main.py
 -rw-rw-r--  2.0 unx      153 b- defN 23-May-05 16:00 k1lib/serve/suffix-dash.py
 -rw-rw-r--  2.0 unx      642 b- defN 23-Feb-13 19:00 k1lib/serve/suffix.py
--rw-rw-r--  2.0 unx  2453826 b- defN 23-Jan-19 22:50 k1lib-1.3.9.4.data/data/k1lib/k1ui/256.model.state_dict.pth
--rw-rw-r--  2.0 unx   304735 b- defN 23-Jan-17 19:16 k1lib-1.3.9.4.data/data/k1lib/k1ui/mouseKey.pth
--rw-rw-r--  2.0 unx    20544 b- defN 23-Mar-19 11:14 k1lib-1.3.9.4.data/data/k1lib/serve/main.html
--rw-rw-r--  2.0 unx     1049 b- defN 23-May-26 17:04 k1lib-1.3.9.4.dist-info/LICENSE
--rw-rw-r--  2.0 unx     3890 b- defN 23-May-26 17:04 k1lib-1.3.9.4.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 23-May-26 17:04 k1lib-1.3.9.4.dist-info/WHEEL
--rw-rw-r--  2.0 unx        6 b- defN 23-May-26 17:04 k1lib-1.3.9.4.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     6704 b- defN 23-May-26 17:04 k1lib-1.3.9.4.dist-info/RECORD
-84 files, 3531841 bytes uncompressed, 2537712 bytes compressed:  28.2%
+-rw-rw-r--  2.0 unx  2453826 b- defN 23-Jan-19 22:50 k1lib-1.4.data/data/k1lib/k1ui/256.model.state_dict.pth
+-rw-rw-r--  2.0 unx   304735 b- defN 23-Jan-17 19:16 k1lib-1.4.data/data/k1lib/k1ui/mouseKey.pth
+-rw-rw-r--  2.0 unx    20544 b- defN 23-Mar-19 11:14 k1lib-1.4.data/data/k1lib/serve/main.html
+-rw-rw-r--  2.0 unx     1049 b- defN 23-May-30 07:53 k1lib-1.4.dist-info/LICENSE
+-rw-rw-r--  2.0 unx     3886 b- defN 23-May-30 07:53 k1lib-1.4.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 23-May-30 07:53 k1lib-1.4.dist-info/WHEEL
+-rw-rw-r--  2.0 unx        6 b- defN 23-May-30 07:53 k1lib-1.4.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     6672 b- defN 23-May-30 07:53 k1lib-1.4.dist-info/RECORD
+84 files, 3539366 bytes uncompressed, 2540295 bytes compressed:  28.2%
```

## zipnote {}

```diff
@@ -222,32 +222,32 @@
 
 Filename: k1lib/serve/suffix-dash.py
 Comment: 
 
 Filename: k1lib/serve/suffix.py
 Comment: 
 
-Filename: k1lib-1.3.9.4.data/data/k1lib/k1ui/256.model.state_dict.pth
+Filename: k1lib-1.4.data/data/k1lib/k1ui/256.model.state_dict.pth
 Comment: 
 
-Filename: k1lib-1.3.9.4.data/data/k1lib/k1ui/mouseKey.pth
+Filename: k1lib-1.4.data/data/k1lib/k1ui/mouseKey.pth
 Comment: 
 
-Filename: k1lib-1.3.9.4.data/data/k1lib/serve/main.html
+Filename: k1lib-1.4.data/data/k1lib/serve/main.html
 Comment: 
 
-Filename: k1lib-1.3.9.4.dist-info/LICENSE
+Filename: k1lib-1.4.dist-info/LICENSE
 Comment: 
 
-Filename: k1lib-1.3.9.4.dist-info/METADATA
+Filename: k1lib-1.4.dist-info/METADATA
 Comment: 
 
-Filename: k1lib-1.3.9.4.dist-info/WHEEL
+Filename: k1lib-1.4.dist-info/WHEEL
 Comment: 
 
-Filename: k1lib-1.3.9.4.dist-info/top_level.txt
+Filename: k1lib-1.4.dist-info/top_level.txt
 Comment: 
 
-Filename: k1lib-1.3.9.4.dist-info/RECORD
+Filename: k1lib-1.4.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## k1lib/__init__.py

```diff
@@ -6,29 +6,29 @@
 from ._perlin import *
 from ._baseClasses import *
 from ._context import *
 from . import cli
 from ._higher import *
 from ._monkey import *
 
-from . import fmt;      fmt      = wrapMod(fmt)
-from . import knn;      knn      = wrapMod(knn)
-from . import selector; selector = wrapMod(selector)
+from . import fmt;      #fmt      = wrapMod(fmt)
+from . import knn;      #knn      = wrapMod(knn)
+from . import selector; #selector = wrapMod(selector)
 from .callbacks import Callback, Callbacks, Cbs
 from . import callbacks
 from ._learner import *
-from . import schedule; schedule = wrapMod(schedule)
-from . import viz;      viz      = wrapMod(viz)
+from . import schedule; #schedule = wrapMod(schedule)
+from . import viz;      #viz      = wrapMod(viz)
 from . import _k1a;
 from . import k1ui;     #k1ui     = wrapMod(k1ui)
 from . import serve;
 from . import p5;
 
 #from . import gE
-from . import eqn;      eqn      = wrapMod(eqn)
+from . import eqn;      #eqn      = wrapMod(eqn)
 
 class _Mo(wrapMod):
     def __init__(self, mod): super().__init__(mod); self._MoWrap_dirs = ["registerSubstance"]
     def registerSubstance(self, name:str, _f):
         setattr(_Mo, name, property(lambda self: _f())); self._MoWrap_dirs.append(name)
     def __dir__(self): return super().__dir__() + self._MoWrap_dirs
 from . import _mo; mo = _Mo(_mo)
```

## k1lib/_baseClasses.py

```diff
@@ -430,33 +430,40 @@
         """Increments internal counter, and return it."""
         self._value += 1
         if self._value >= self.n: self._value = 0
         return self.value
 class Wrapper:
     value:Any
     """Internal value of this :class:`Wrapper`"""
-    def __init__(self, value):
+    def __init__(self, value=None):
         """Creates a wrapper for some value and get it by calling it.
 Example::
 
-    a = k1lib.Wrapper(list(range(int(1e7))))
+    a = k1.Wrapper(list(range(int(1e7))))
     # returns [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
     a()[:10]
 
 This exists just so that Jupyter Lab's contextual help won't automatically
 display the (possibly humongous) value. Could be useful if you want to pass a
 value by reference everywhere like this::
 
-    o = k1lib.Wrapper(None)
+    o = k1.Wrapper(None)
     def f(obj):
         obj.value = 3
     f(o)
-    o() # returns 3"""
+    o() # returns 3
+
+You can also pipe into it like this:
+
+    o = 3 | k1.Wrapper()
+    o() # returns 3
+"""
         self.value = value
     def __call__(self): return self.value
+    def __ror__(self, it): self.value = it; return self
 class Every:
     def __init__(self, n):
         """Returns True every interval.
 Example::
 
     e = k1lib.Every(4)
     e() # returns True
```

## k1lib/fmt.py

```diff
@@ -5,16 +5,16 @@
 
    from k1lib.imports import *
    fmt.txt # exposed
 """
 import k1lib, math; from k1lib import cli
 from typing import Dict, Iterator, Tuple
 pygments = k1lib.dep("pygments")
-__all__ = ["generic", "metricPrefixes", "size", "sizeOf",
-           "comp", "compRate", "time", "item", "throughput", "txt", "code", "h", "pre", "row", "col"]
+__all__ = ["generic", "metricPrefixes", "size", "fromSize", "sizeOf",
+           "comp", "compRate", "time", "item", "throughput", "txt", "code", "h", "pre", "row", "col", "colors"]
 k1lib.settings.add("fmt", k1lib.Settings().add("separator", True, "whether to have a space between the number and the unit"), "from k1lib.fmt module");
 settings = k1lib.settings.fmt
 metricPrefixes = {-8:"y",-7:"z",-6:"a",-5:"f",-4:"p",-3:"n",-2:"u",-1:"m",0:"",1:"k",2:"M",3:"G",4:"T",5:"P",6:"E",7:"Z",8:"Y"}
 #metricPrefixes = ["", "k", "M", "G", "T", "P", "E", "Z", "Y"]
 def generic(x, units:Dict[int, str]):
     c = " " if settings.separator else ""
     for i, unit in units.items():
@@ -194,8 +194,17 @@
     return args | cli.apply(lambda x: f"<div style='margin: 10px'>{x}</div>") | cli.join("") | cli.aS(lambda x: f"<div style='display: flex; flex-direction: column'>{x}</div>")
 def row(args):
     """Creates a html row of all the elements.
 Example::
 
     fmt.row(["abc", "def"]) | aS(IPython.display.HTML)
 """
-    return args | cli.apply(lambda x: f"<div style='margin: 10px'>{x}</div>") | cli.join("") | cli.aS(lambda x: f"<div style='display: flex; flex-direction: row'>{x}</div>")
+    return args | cli.apply(lambda x: f"<div style='margin: 10px'>{x}</div>") | cli.join("") | cli.aS(lambda x: f"<div style='display: flex; flex-direction: row'>{x}</div>")
+settings.add("colors", ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"], "List of colors to cycle through in fmt.colors()")
+def colors():
+    """Returns an infinite iterator that cycles through 12 colors.
+Example::
+
+    fmt.colors() | head(3) | deref()
+
+Color scheme taken from https://colorbrewer2.org/#type=qualitative&scheme=Set3&n=12"""
+    return settings.colors | cli.repeatFrom()
```

## k1lib/viz.py

```diff
@@ -10,14 +10,16 @@
 import matplotlib.pyplot as plt, numpy as np
 from typing import Callable, List, Union
 from functools import partial, update_wrapper
 try: import torch; import torch.nn as nn; hasTorch = True
 except:
     torch = k1lib.Object().withAutoDeclare(lambda: type("RandomClass", (object, ), {}))
     nn = k1lib.Object().withAutoDeclare(lambda: type("RandomClass", (object, ), {})); hasTorch = False
+try: import PIL; hasPIL = True
+except: hasPIL = False
 __all__ = ["SliceablePlot", "plotSegments", "Carousel", "Toggle", "ToggleImage",
            "Scroll", "confusionMatrix", "FAnim", "mask"]
 class _PlotDecorator:
     """The idea with decorators is that you can do something like this::
 
     sp = k1lib.viz.SliceablePlot()
     sp.yscale("log") # will format every plot as if ``plt.yscale("log")`` has been called
@@ -179,25 +181,36 @@
 
     c = viz.Carousel()
     x = np.linspace(-2, 2); plt.plot(x, x ** 2); plt.gcf() | toImg() | c
     x = np.linspace(-1, 3); plt.plot(x, x ** 2); plt.gcf() | toImg() | c
     "<h1>abc</h1><div>Some content</div>" | c # can add html
     c # displays in notebook cell
 
-:param imgs: List of initial images. Can add more images later on by using :meth:`__ror__`
-
 .. image:: images/carousel.png
+
+You can also pipe the content into it like this::
+
+    ["abc", "def"] | viz.Carousel()
+    ["abc", "def"] | aS(viz.Carousel) # also valid, but kinda outdated and unintuitive
+
+:param imgs: List of initial images. Can add more images later on by using :meth:`__ror__`
 """
         self.imgs:List[Tuple[str, str]] = [] # Tuple[format, base64 img]
         self.defaultFormat = "jpeg"
         for im in imgs: im | self
     def __ror__(self, d):
         """Adds an image/html content to the collection"""
         if isinstance(d, str): self.imgs.append(k1lib.encode(f"{d}"))
-        else: self.imgs.append(k1lib.encode(f"<img alt='' style='max-width: 100%' src='data:image/png;base64, {base64.b64encode(d | cli.toBytes()).decode()}' />"))
+        elif hasPIL and isinstance(d, PIL.Image.Image):
+            self.imgs.append(k1lib.encode(f"<img alt='' style='max-width: 100%' src='data:image/png;base64, {base64.b64encode(d | cli.toBytes()).decode()}' />"))
+        else:
+            try:
+                for e in d: e | self
+            except e: warnings.warn("Tried to add html/image to Carousel but can't due to this error"); raise e
+        return self
     def pop(self):
         """Pops last image"""
         return self.imgs.pop()
     def __getitem__(self, idx): return self.imgs[idx]
     def _repr_html_(self):
         idx = Carousel._idx()
         pre = f"k1c_{idx}"
```

## k1lib/cli/_applyCl.py

```diff
@@ -195,29 +195,29 @@
     if nAs is None: nAs = None | applyCl.aS(lambda: os.path.exists(fn)) | filt(op(), 1) | cut(0) | deref()
     if nBs is None: nBs = applyCl.nodeIds()
     decommission(fn, *nAs | inSet(nBs).split() | reverse(), rS)
     spreadOut(fn, *nBs | inSet(nAs).split(), rS)
 def diskScan1(base:str) -> List[str]: # like ls(), but returns files and folders that appear at least on 2 nodes
     isdir, base = base.split("\ue000")
     if not isdir: return []
-    return None | applyCl.aS(lambda: base | (tryout([]) | ls() | apply(os.path.isdir) & iden() | transpose() | ~apply(lambda x,y: f"{x*1}\ue000{y}")) | deref()) | cut(1) | joinStreams() | count() | filt(op()>1, 0) | cut(1) | deref()
+    return None | applyCl.aS(lambda: base | (tryout([]) | ls() | apply(os.path.isdir) & iden() | transpose() | ~apply(lambda x,y: f"{x*1}\ue000{y}")) | deref(), timeout=60) | cut(1) | joinStreams() | count() | filt(op()>1, 0) | cut(1) | deref()
 def diskScan2(base:str) -> Tuple[List[str], List[str]]: # returns list of distributed folders and list of distributed files
     dFolders = []; folders, files = diskScan1(base) | op().split("\ue000").all() | toInt(0) | filt(op(), 0).split() | (join("\ue000")).all(2) | deref()
     # print("2--", folders, files, base)
     for folder in folders:
         fol, fil = diskScan2(folder); dFolders.extend(fol); files.extend(fil)
         if len(fol) + len(fil) == 0: dFolders.append(folder) # no shared contents, must be a distributed folder
         else: files.extend(fil)
     # print("3--", [dFolders, files], base)
     return [dFolders, files]
 def diskScan3(base:str): base = os.path.expanduser(base); return diskScan2(f"1\ue000{base}") | op().split("\ue000")[1].all(2) | deref()
 def diskScan4(base:str, sortSize=True): # fully featured data
     folders, files = diskScan3(base)
-    folders = [folders, None | applyCl.aS(lambda: folders | apply(lambda x: (x | getFolderSize) if os.path.exists(x) else 0) | deref()) | cut(1) | transpose()] | transpose() | deref()
-    files   = [files,   None | applyCl.aS(lambda: files   | apply(lambda x: os.path.getsize(x)  if os.path.exists(x) else 0) | deref()) | cut(1) | transpose()] | transpose() | deref()
+    folders = [folders, None | applyCl.aS(lambda: folders | apply(lambda x: (x | getFolderSize) if os.path.exists(x) else 0) | deref(), timeout=60) | cut(1) | transpose()] | transpose() | deref()
+    files   = [files,   None | applyCl.aS(lambda: files   | apply(lambda x: os.path.getsize(x)  if os.path.exists(x) else 0) | deref(), timeout=60) | cut(1) | transpose()] | transpose() | deref()
     post = apply(~sortF(toSum(), 1)) if sortSize else iden()
     return [folders, files] | wrapList() + filt(filt(op() > 0) | count() | shape(0) | (op() == 1), 1).split() | joinStreams() | apply(unique(0)) | post | deref()
 def diskScan5(base:str, sortSize=True): # displays it in a nice format
     d4 = diskScan4(base, sortSize); lens = d4 | apply(len) | deref(); nodeNames = None | applyCl.aS(lambda: os.cpu_count()) | apply(op()[:5], 0) | apply('f"{x} thr"', 1) | join(", ").all() | deref(); nodeNames
     d5 = d4 | apply(~apply(lambda path, sizes: [path, sizes | toSum() | aS(fmt.size), sizes | apply(fmt.size)]) | insert(["-"*40, "-"*10, ["-"*12]*len(nodeNames)]) | insert(["", "", nodeNames])) | deref(); d5
     ws = d5 | shape(0).all() | deref()
     d6 = d5 | joinStreams() | cut(0, 1) & (cut(2) | pretty() | wrapList().all()) | transpose() | joinStreams().all() | splitW(*ws) | insert(["Path", "Total size", "Size on each node (node id and thread count)"]).all() | joinStreams() | pretty() | splitW(*ws | apply(op()+1)) | deref()
```

## k1lib/cli/filt.py

```diff
@@ -8,15 +8,15 @@
 from k1lib.cli.typehint import *
 import numpy as np; from collections import deque
 try: import torch; hasTorch = True
 except: hasTorch = False
 __all__ = ["filt", "filter_", "inSet", "contains", "empty",
            "isNumeric", "instanceOf",
            "head", "tail", "cut", "rows",
-           "intersection", "union", "unique", "breakIf", "mask", "tryout"]
+           "intersection", "union", "unique", "breakIf", "mask", "tryout", "resume"]
 settings = k1lib.settings.cli
 class filt(BaseCli):
     def __init__(self, predicate:Callable[[T], bool], column:int=None, catchErrors:bool=False):
         """Filters out elements.
 Examples::
 
     # returns [2, 6], grabbing all the even elements
@@ -623,8 +623,34 @@
                         if patience <= 0: savedInputs().popleft(); patience = retries
                         else: patience -= 1
                         # restart the loop
                         it = interceptIt([list(savedInputs()), ogIt] | cli.joinStreams())
                         savedInputs.value = deque(); outIt = it | self.capturedSerial
                         if patience == retries: yield str(e) if self.result is str else self.result
             return gen(it)
-    def __invert__(self): self.inverted = not self.inverted; return self
+    def __invert__(self): self.inverted = not self.inverted; return self
+def resume(fn):
+    """Resumes a long-running operation. I usually have code that
+looks like this::
+
+    def f(x): pass # long running, expensive calculation
+    ls(".") | applyMp(f) | apply(dill.dumps) | file("somefile.pth") # executing
+    cat.pickle("somefile.pth") | aS(list) # getting all of the saved objects
+
+This will read all the files in the current directory, transforms
+them using the long-running, expensive function, potentially doing
+it in multiple processes. Then the results are serialized (turns into
+bytes) and it will be appended to an output file.
+
+What's frustrating is that I do stupid things all the time, so the
+process usually gets interrupted. But I don't want to redo the
+existing work, so that's where this cli comes into play. Now it looks
+like this instead::
+
+    ls(".") | resume("somefile.pth") | applyMp(f) | apply(dill.dumps) >> file("somefile.pth")
+
+Note that we're inserting a resume() AND changed the file write mode
+to append, so that the file doesn't get overriden. Internally, this is
+just a shorthand for ``~head(fn | (tryout(0) | aS(cat.pickle) | shape(0)))``
+
+:param fn: file name"""
+    return ~cli.head(fn | (cli.tryout(0) | cli.aS(cli.cat.pickle) | cli.shape(0)))
```

## k1lib/cli/init.py

```diff
@@ -225,83 +225,87 @@
     if isinstance(c, cli.op): return c.ab_fastF()
     if isinstance(c, cli.applyS):
         f = fastF(c.f)
         if len(c.args) == 0 and len(c.kwargs) == 0: return f
         else: return lambda x, *args, **kwargs: f(x, *c.args, **c.kwargs)
     if isinstance(c, BaseCli): return c.__ror__
     return c
+def checkRor(c):
+    if isinstance(c, BaseCli): return c
+    if hasattr(c, "__ror__"): return cli.aS(c.__ror__)
+    raise Exception(f"Trying to add an operator to the pipeline, but the given object is not derived from BaseCli nor does it define a __ror__ method")
 class serial(BaseCli):
     def __init__(self, *clis:List[BaseCli]):
         """Merges clis into 1, feeding end to end. Used in chaining clis
 together without a prime iterator. Meaning, without this, stuff like this
 fails to run::
 
     [1, 2] | a() | b() # runs
     c = a() | b(); [1, 2] | c # doesn't run if this class doesn't exist"""
-        fs = list(clis); super().__init__(fs); self.clis = fs; self._cache()
+        fs = [checkRor(c) for c in clis]; super().__init__(fs); self.clis = fs; self._cache()
     def _cache(self):
         self._hasTrace = any(isinstance(c, cli.trace) for c in self.clis)
         self._cliCs = [fastF(c) for c in self.clis]; return self
     def _typehint(self, inp=None):
         for c in self.clis: inp = c._typehint(inp) or cli.typehint.tAny()
         return inp
     def __ror__(self, it:Iterator[Any]) -> Iterator[Any]:
         if self._hasTrace: # slower, but tracable
             for cli in self.clis: it = it | cli
-        else: # faster, but not tracable
+        else: # faster, but not tracable 1
             for cli in self._cliCs: it = cli(it)
         return it
-    def _before(self, c): self.clis = [c] + self.clis; return self._cache()
-    def _after(self, c): self.clis = self.clis + [c]; return self._cache()
+    def _before(self, c): self.clis = [checkRor(c)] + self.clis; return self._cache()
+    def _after (self, c): self.clis = self.clis + [checkRor(c)]; return self._cache()
     def _copy(self): return serial(*self.clis)
 atomic.add("baseAnd", (Number, np.number, str, dict, bool, bytes, list, tuple, *([torch.Tensor] if hasTorch else []), np.ndarray, xml.etree.ElementTree.Element), "used by BaseCli.__and__")
 def _iterable(it):
     try: iter(it); return True
     except: return False
 class oneToMany(BaseCli):
     def __init__(self, *clis:List[BaseCli]):
         """Duplicates 1 stream into multiple streams, each for a cli in the
 list. Used in the "a & b" joining operator. See also: :meth:`BaseCli.__and__`"""
-        fs = list(clis); super().__init__(fs); self.clis = fs; self._cache()
+        fs = [checkRor(c) for c in clis]; super().__init__(fs); self.clis = fs; self._cache()
     def _typehint(self, inp):
         ts = []
         for f in self.clis:
             try: ts.append(f._typehint(inp))
             except: ts.append(cli.typehint.tAny())
         return cli.typehint.tCollection(*ts).reduce()
     def __ror__(self, it:Iterator[Any]) -> Iterator[Iterator[Any]]:
         if isinstance(it, atomic.baseAnd) or isinstance(it, k1lib.cli.splitSeek) or not _iterable(it):
             for cli in self._cliCs: yield cli(it)
         else:
             its = itertools.tee(it, len(self.clis))
             for cli, it in zip(self._cliCs, its): yield cli(it)
     def _cache(self): self._cliCs = [fastF(c) for c in self.clis]; return self
-    def _before(self, c): self.clis = [c] + self.clis; return self._cache()
-    def _after(self, c): self.clis = self.clis + [c]; return self._cache()
+    def _before(self, c): self.clis = [checkRor(c)] + self.clis; return self._cache()
+    def _after(self, c): self.clis = self.clis + [checkRor(c)]; return self._cache()
     def _copy(self): return oneToMany(*self.clis)
 class mtmS(BaseCli):
     def __init__(self, *clis:List[BaseCli]):
         """Applies multiple streams to multiple clis independently. Used in
 the "a + b" joining operator. See also: :meth:`BaseCli.__add__`.
 
 Weird name is actually a shorthand for "many to many specific"."""
-        fs = list(clis); super().__init__(fs=fs); self.clis = fs; self._cache()
+        fs = [checkRor(c) for c in clis]; super().__init__(fs=fs); self.clis = fs; self._cache()
     def _inpTypeHintExpand(self, t):
         n = len(self.clis);
         if isinstance(t, (cli.typehint.tCollection, *cli.typehint.tListIterSet, cli.typehint.tArrayTypes)): return t.expand(n)
         else: return [cli.typehint.tAny()]*n
     def _typehint(self, t):
         n = len(self.clis); outTs = []
         for c, t in zip(self.clis, self._inpTypeHintExpand(t)):
             try: outTs.append(c._typehint(t))
             except: outTs.append(cli.typehint.tAny())
         return cli.typehint.tCollection(*outTs).reduce()
     def _cache(self): self._cliCs = [fastF(c) for c in self.clis]; return self
-    def _before(self, c): self.clis = [c] + self.clis; return self._cache()
-    def _after(self, c): self.clis = self.clis + [c]; return self._cache()
+    def _before(self, c): self.clis = [checkRor(c)] + self.clis; return self._cache()
+    def _after (self, c): self.clis = self.clis + [checkRor(c)]; return self._cache()
     def __ror__(self, its:Iterator[Any]) -> Iterator[Any]:
         for cli, it in zip(self._cliCs, its): yield cli(it)
     @staticmethod
     def f(f, i:int, n:int=100):
         """Convenience method, so
 that this::
```

## k1lib/cli/inp.py

```diff
@@ -5,15 +5,15 @@
 from collections import deque
 from k1lib.cli import BaseCli; import k1lib.cli as cli
 from k1lib.cli.typehint import *
 from contextlib import contextmanager
 requests = k1lib.dep("requests")
 try: import minio; hasMinio = True
 except: hasMinio = False
-__all__ = ["cat", "splitSeek", "refineSeek", "wget", "ls", "cmd", "walk", "requireCli", "urlPath"]
+__all__ = ["cat", "splitSeek", "refineSeek", "wget", "ls", "cmd", "walk", "requireCli", "urlPath", "kzip", "kunzip", "unzip"]
 settings = k1lib.settings.cli
 class NoPartialContent(Exception): pass
 def getChunk(url:str, sB:int, eB:int, timeout:float, retries:int) -> bytes: # start inclusive, end exclusive
     for i in range(retries):
         try: res = requests.get(url, headers={"Range": f"bytes={sB}-{eB-1}"}, timeout=timeout)
         except Exception as e:
             if i >= retries-1: raise Exception(f"Can't get file chunk")
@@ -137,15 +137,17 @@
                     if b > eB: yield line[:len(line)-(b-eB)]; return
                     yield line[:-1] if line[-1] == "\n" else line
     except FileNotFoundError: pass
 def _catGenBin(fn, sB, eB):
     chunkSize = settings.cat.chunkSize; sB = wrap(fn, sB); eB = wrap(fn, eB); nB = eB - sB # number of bytes to read total
     with openFile(fn, False) as f:
         f.seek(sB); nChunks = math.ceil(nB / chunkSize); lastChunkSize = nB - chunkSize*(nChunks-1)
-        yield from range(nChunks) | cli.applyTh(lambda i: f.read(chunkSize) if i < nChunks-1 else f.read(chunkSize)[:lastChunkSize], prefetch=10)
+        # had to do this because RemoteFile is actually not thread-safe
+        applyF = (lambda f_: cli.apply(f_)) if isinstance(f, RemoteFile) else (lambda f_: cli.applyTh(f_, prefetch=10))
+        yield from range(nChunks) | applyF(lambda i: f.read(chunkSize) if i < nChunks-1 else f.read(chunkSize)[:lastChunkSize])
 def fileLength(fn):
     with openFile(fn, False) as f: return f.seek(0, os.SEEK_END)
 def wrap(fn, b): return b if b >= 0 else b + fileLength(fn) + 1
 class _cat(BaseCli):
     def __init__(self, text, chunks, sB, eB): self.text = text; self.chunks = chunks; self.sB = sB; self.eB = eB
     def _typehint(self, ignored=None):
         if self.text: return tIter(str) if self.chunks else tList(str)
@@ -628,9 +630,92 @@
     url | urlPath(base, False) # returns "~/ssd/some/other/path/some/path/to/file.txt"
 
 :param base: base directory you want the files to be in"""
     base = base.rstrip("/\\")
     def inner(url):
         p = urllib.parse.urlparse(url)
         a = (p.netloc.replace(".", "_") + os.sep) if host else ""
-        return f"{base}{os.sep}{a}{p.path.strip('/')}"
-    return cli.aS(inner)
+        return f"{base}{os.sep}{a}{p.path.strip('/')}".replace("//", "/")
+    return cli.aS(inner)
+import bz2, gzip, zlib
+puremagic = k1lib.dep("puremagic")
+class kzip(BaseCli):
+    def __init__(self, fmt="gz"):
+        """Incrementally compresses a stream of data using gzip or bzip2.
+Example::
+
+    data = range(100) | apply(lambda x: str(x).encode()) | deref() # list of bytes
+    data | kzip() | deref() # returns list of bytes
+
+Why "kzip" and not just "zip"? Because "zip" is a builtin python keyword.
+
+See also: :class:`kunzip`
+
+:param fmt: desired compressed format. Currently only supports "gz" or "bz2"
+"""
+        fmt = fmt.strip(".")
+        if fmt == "gzip" or fmt == "gz":
+            self.o = zlib.compressobj(wbits=31)
+        elif fmt == "bzip2" or fmt == "bz2":
+            self.o = bz2.BZ2Compressor()
+        else: raise Exception(f"File type {fmt} not supported. Specify either 'gz' or 'bz2'")
+    def __ror__(self, it):
+        o = self.o
+        for e in it:
+            res = o.compress(e)
+            if res: yield res
+        try:
+            res = o.flush()
+            if res: yield res
+        except: pass
+class kunzip(BaseCli):
+    def __init__(self, text=False):
+        """Incrementally decompress a stream of data using gzip or bzip2.
+Example::
+
+    # returns an iterator of bytes. cat() command can shorten to cat("someFile.gz", False, True)
+    cat("someFile.gz", text=False, chunks=True) | kunzip()
+    # incrementally fetches remote file, then incrementally unzips it
+    cat("https://example.com/someFile.gz", False, True) | kunzip()
+
+    data = range(100) | apply(lambda x: str(x).encode()) | deref() # list of bytes
+    data | kzip() | kunzip() | deref() # returns original data in list of bytes. May split the bytes at different positions though
+
+How does it know which algorithm to pick to decompress? It looks at the
+first few bytes of the file for its magic number. Also, if you're expecting
+a text file after decompression, you can do this to get the lines directly::
+
+    # returns iterator of strings
+    cat("https://example.com/someFile.gz", False, True) | kunzip(True)
+
+One more thing. If you're planning to use this to download whole files, you might
+want to tune the chunk size in :data:`~k1lib.settings`.cli.cat.chunkSize as
+it might speed things up considerably to raise it. Or may be you should just
+use wget instead =))
+
+See also: :class:`kzip`. There's also an alias to this cli: :class:`unzip`
+
+:param text: whether to yield string lines or bytes"""
+        self.text = text
+    def __ror__(self, it):
+        def gen(it):
+            it = iter(it); e = next(it); magic = puremagic.from_string(e).split(".")[-1]
+            if magic == "gz": o = zlib.decompressobj(zlib.MAX_WBITS|32)
+            elif magic == "bz2": o = bz2.BZ2Decompressor()
+            else: raise Exception("Can't infer the file type (whether gz or bz2) of this file")
+            res = o.decompress(e)
+            if res: yield res
+            for e in it:
+                res = o.decompress(e)
+                if res: yield res
+            try:
+                res = o.flush()
+                if res: yield res
+            except: pass
+        if self.text:
+            def gen2(it):
+                for e in gen(it):
+                    for line in e.split(b"\n"):
+                        yield line.decode()
+            return gen2(it)
+        else: return gen(it)
+unzip = kunzip
```

## k1lib/cli/modifier.py

```diff
@@ -876,14 +876,41 @@
 Example::
 
     # returns list of 10 node ids: ["abc...", "def...", "abc...", ...]
     applyCl.balancedNodeIds() | head() | deref()
 """
         from k1lib.cli._applyCl import balancedNodeIds
         return balancedNodeIds()
+    @staticmethod
+    def loadTest():
+        """Performs a load test on the cluster.
+Example::
+
+    applyCl.loadTest()
+
+What is a load test? It basically tries to perform some intensive and
+long-running calculations on all processes on all nodes in the cluster
+to know how good are each individual nodes. This is useful information
+because whenever you try to split a file up to form a distributed file,
+or move files in a folder around to form a distributed folder, the amount
+of data each node gets is going to be proportional to this performance
+information. More powerful nodes will have more data to process, so that
+the total running time across all nodes is going to roughly be the same.
+
+But isn't cpu count good enough for this? No, not actually. The i7 7700
+has 4 cores, 8 threads, and the i9 13900k has 8 performance cores and 16
+efficiency cores, totalling to 32 threads. You would suspect that the
+13900k to be 4x (32/8=4) or 6x (24/4=6) more powerful than the 7700, but
+it's actually 10x more powerful.
+
+The test itself takes around 1-2 minutes, and the test results are going
+to be saved locally in the folder "~/.k1lib/", so that it can use that
+info directly in future runs."""
+        from k1lib.cli._applyCl import loadTest
+        return loadTest()
 thEmptySentinel = object()
 class applyTh(BaseCli):
     def __init__(self, f, prefetch:int=None, timeout:float=5, bs:int=1, **kwargs):
         """Kinda like the same as :class:`applyMp`, but executes ``f`` on multiple
 threads, instead of on multiple processes. Advantages:
 
 - Relatively low overhead for thread creation
```

## Comparing `k1lib-1.3.9.4.data/data/k1lib/k1ui/256.model.state_dict.pth` & `k1lib-1.4.data/data/k1lib/k1ui/256.model.state_dict.pth`

 * *Files identical despite different names*

## Comparing `k1lib-1.3.9.4.data/data/k1lib/k1ui/mouseKey.pth` & `k1lib-1.4.data/data/k1lib/k1ui/mouseKey.pth`

 * *Files identical despite different names*

## Comparing `k1lib-1.3.9.4.data/data/k1lib/serve/main.html` & `k1lib-1.4.data/data/k1lib/serve/main.html`

 * *Files identical despite different names*

## Comparing `k1lib-1.3.9.4.dist-info/LICENSE` & `k1lib-1.4.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `k1lib-1.3.9.4.dist-info/METADATA` & `k1lib-1.4.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: k1lib
-Version: 1.3.9.4
+Version: 1.4
 Summary: Some nice ML overhaul
 Home-page: https://k1lib.com
 Author: Quang Ho
 Author-email: 157239q@gmail.com
 License: MIT
 Requires-Python: >=3.7
 Description-Content-Type: text/markdown
```

## Comparing `k1lib-1.3.9.4.dist-info/RECORD` & `k1lib-1.4.dist-info/RECORD`

 * *Files 8% similar despite different names*

```diff
@@ -1,25 +1,25 @@
-k1lib/__init__.py,sha256=zdjKwxgRuNNLKhHen5zaW-zmo6DmOlGBR9frAQI0jh0,1435
-k1lib/_baseClasses.py,sha256=bwUkhuJcp5RJMJxHuDcGTF5cwenBFZIqouIluChPtB0,53798
+k1lib/__init__.py,sha256=tHszZf_A_U-Pq3S5ag6Q6xVDZiRLA6VRxRkikl6BwRA,1441
+k1lib/_baseClasses.py,sha256=D7pr1oLqNwFu98Vt8W20zTKGSXOuU5vYlEIDy5wm-o8,53938
 k1lib/_basics.py,sha256=f9Hn4UTRfhbzKotZ9eRMmb4Ic8A4_1ORP0qWnInkLu8,13494
 k1lib/_context.py,sha256=wZB8OhBZiJNgfk-CA9tVWmhyC38J-6vVXSn1vEIkCtE,4908
 k1lib/_higher.py,sha256=BZ54rlMNygGrKBZjLpakicQ_FDSt936X5sgfJnvns2Y,2866
 k1lib/_k1a.py,sha256=i-_CPMBdiE-CCI375eaguwcC01dGHar4SlaaQDFsRwg,948
 k1lib/_learner.py,sha256=63aPrhGE5jO1YApvsIcn_HXA1E4ttLfyZVkIUE-meqA,11646
 k1lib/_monkey.py,sha256=ojty9WZTOcW0NVajMLuL_5Dn_1523i5ONvok3m8hbGU,21467
 k1lib/_perlin.py,sha256=sL4B8caVEz4xgWj65Oy3FYxELGDM8wPAtsn0Ro8R3dc,3571
 k1lib/eqn.py,sha256=1wchJwyCIOxbEzf9keQsnvhQfqbHe_cgPzI2crtuHRw,13377
-k1lib/fmt.py,sha256=gtJo-T5Th94z0eOCo8dodP1MsfWEMIMiCsQkXFJBr2o,6850
+k1lib/fmt.py,sha256=9YEjiYLGA9VGkCypCLfj-_oSc_9kcWRCBiQZknXh8Vw,7343
 k1lib/graphEqn.py,sha256=DkdJlDcgC8THRuOFXGsbNuuA94_pUYy3jaU7XcggDLw,6398
 k1lib/imports.py,sha256=kW-HdhcJFE_OXO8Oh5PePyYCSHwhc6fhfdu5ZQgFua4,2750
 k1lib/knn.py,sha256=LASgb0z_9x1u4eZTsat_FspX1g5aIyxjkEWHhKRTn1g,3107
 k1lib/p5.py,sha256=nB0XmMXSz6CuDDZveGgsMCMhoKBXOG_rF0tjkCxJCec,3564
 k1lib/schedule.py,sha256=g5ZBD5zSRSjANsNAmBRoCiYpRkFsHUpjwNuj_goiD0w,8077
 k1lib/selector.py,sha256=lF7Qq-YuVbP2-kPEqBQo0dVy1SOMfH_REcheZ1G693o,17767
-k1lib/viz.py,sha256=sTg9pABXmCyWl8K-jzKIpZwBMy9nllsmn_p9s7UAU1Q,16718
+k1lib/viz.py,sha256=eJVYsCNFbkWprPDJKBIOo5TMKeUEBWpPvmihmRYFRqA,17201
 k1lib/_hidden/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 k1lib/_hidden/hiddenFile.py,sha256=v05pb9A7xcuzIJ0zLt4rTp6mZ4zP6QFkn9UN4qmC9G4,79
 k1lib/_mo/__init__.py,sha256=1cn6kpsev735HU4hNTRzOiHgU0bwyxIJoNhOxzLRto4,615
 k1lib/_mo/atom.py,sha256=zlApQ5T4tqpSlR4a7rh4MrpviF1lyAsNAh_3Mxxf1Xs,13464
 k1lib/_mo/parseM.py,sha256=rQcexNBCG4OcVmQNkmD5YFM8YCAGfrE0g0GIlX7lmX4,9629
 k1lib/_mo/substance.py,sha256=TT97U9rKW3-xTLOeFa0G2Kn1Zj0let_vTtkyKp6pbNk,2471
 k1lib/_mo/system.py,sha256=mxYdg-i8CoD0fyOooW4W17wx-2j9vWtZG5-ZGXnnnQE,9067
@@ -42,27 +42,27 @@
 k1lib/callbacks/lossFunctions/shorts.py,sha256=wXeUSgGDIdu_nsiAvn4pKs3fQrcO2FwpNXKcBCFvGzY,3465
 k1lib/callbacks/profilers/__init__.py,sha256=Gp5IvLRABYAg1J0ilTT2v72gfDbyTvUUHUEpvlSo1Lc,45
 k1lib/callbacks/profilers/computation.py,sha256=gPNsoioghh4PI5w8s2p8qYOrR7XObslqCLH5EkNOPSI,5054
 k1lib/callbacks/profilers/io.py,sha256=H8E0YzmLWRD9T2_RyDG2eXvbQQnJgzEnEyx8PqfQ4wY,2319
 k1lib/callbacks/profilers/memory.py,sha256=L0F5pc5LB0dtSnRot8ReR-amZn1uIXv0py0XmGS166U,4419
 k1lib/callbacks/profilers/time.py,sha256=R2-2ZooDwLQIeyonLp2Zz5E_uXzdy6mWUgw6uavQbpE,4215
 k1lib/cli/__init__.py,sha256=hF0ODhL20OSM9o1j68VhcIVflibgSpPuqeyYlsh8oow,925
-k1lib/cli/_applyCl.py,sha256=dpFCyXFyL0zgW4i_IfWw423cpnx2YUrSMPofAkQNRW4,19109
+k1lib/cli/_applyCl.py,sha256=OeYcwm1JtzaKoA5EeN_d552TYqqR2eyckkToq-s3n_Y,19145
 k1lib/cli/bio.py,sha256=PhGvy-fDA-wrUzzEDpuRe4x-Kbylx0sNmoXCEZfE_FA,8308
 k1lib/cli/cif.py,sha256=77FX83m1FRYEeZkdXJ8MiVapqCSzZ-1xOQ8ZLeHfhf8,4033
 k1lib/cli/conv.py,sha256=KcwSs9mD54XA5BC7ajxPF_1CZsu54i6dH6DtEv_fbv0,19321
-k1lib/cli/filt.py,sha256=50P2-BXGm7qQZ6xr2TUU1CyaNU3h3AiC32p12L01FJo,28497
+k1lib/cli/filt.py,sha256=gwV4XsbrnTnKmE9eUOplezldzGw7hOwYlhTBDHEuZOM,29718
 k1lib/cli/gb.py,sha256=xxjuNYgWrrElRckon3gP0sj-dShYnKs3jmHAb1U0kVI,6672
 k1lib/cli/grep.py,sha256=Lu4PFOe2pkaqd-UfJe_HhHCUFTUifE6Bh96_k80sQDA,6348
-k1lib/cli/init.py,sha256=xr9dgWKhuX_BB3m8fAvNV47tGRGPCv1_vOtRFuHAmsU,19315
-k1lib/cli/inp.py,sha256=LuM-RPkFIXB9MwDdlniDxlog_faeBSn_I8iPIoJKus8,32645
+k1lib/cli/init.py,sha256=U9wuZLxWkpGTaSY9PAONtwpfnVgJ2Aw9RA0uB8IUo_s,19694
+k1lib/cli/inp.py,sha256=tp4geFRvR5mTcBcoeAzgsWjd_Qg4xEfxpiSdK1lw9MA,36178
 k1lib/cli/kcsv.py,sha256=YGUVVLTZGGujokhxtj5MfjU9t1jRGqp23d58JK8lhq0,623
 k1lib/cli/kxml.py,sha256=YQGutvKNm0_xAi_NhCNtuGey7fx3zZSmSo33kS--54c,4819
 k1lib/cli/mgi.py,sha256=aLke90nG89tgWLPwyKmTj3kM8yJnIBCJSrPS1jT8mUk,1915
-k1lib/cli/modifier.py,sha256=7a0IeCds-NFXGf69KvECeMHC5AkTZH7ROvnIjjaUW7w,64689
+k1lib/cli/modifier.py,sha256=5sgEnvaKqOdNZ3YkKztZtVb1At2dbcq8wpgcXGpqub8,65959
 k1lib/cli/mol.py,sha256=wNFuCPXtdEcH4DRBbmYaLAWxtDzjN2MOKFX7ynJhaJs,694
 k1lib/cli/nb.py,sha256=LsNN7OFJ6KzAYKvZpm4fj9WRpsX6Srx6D_xpSTCV328,4038
 k1lib/cli/optimizations.py,sha256=iZ73DwLqZCxRm0sECVZ7A2nDxf5D4rsoSGzrKTgzGaI,3530
 k1lib/cli/output.py,sha256=sGk7Z_kiJ0A_wwRtlJZZgvfqvbl1K-XmNsGih0PlqeA,12118
 k1lib/cli/sam.py,sha256=_ersEPP2ue0Oa3AyftNjQu2PABpH4L7iFBbRJDOkeug,2394
 k1lib/cli/structural.py,sha256=Ugn0Fb-0n0ardjjAvlfsfhRehLeUAszjvkW1odv6ZDU,49390
 k1lib/cli/trace.py,sha256=nzZgOyXqFJYkQfbpR0lpX0Nnp0bQHXPjk8sDUBIe2hk,10399
@@ -70,15 +70,15 @@
 k1lib/cli/utils.py,sha256=XF-H1Ce5ssOw6Dp3htiosHce7xxTgxptrlUsMYxI7uE,21101
 k1lib/k1ui/__init__.py,sha256=8D5a8oKgqd6WA1RUkiKCn4l_PVemtyuckxQut0vDHXM,20
 k1lib/k1ui/main.py,sha256=PnmdOhkjYgRSZnDyGYNMYtQ5Nvcb1NhQ9yjfP_3QORI,61803
 k1lib/serve/__init__.py,sha256=8D5a8oKgqd6WA1RUkiKCn4l_PVemtyuckxQut0vDHXM,20
 k1lib/serve/main.py,sha256=Xh2SzgABfsBp2dRLUJRMftsG_We8ReVHYqXLi3ntMVA,10361
 k1lib/serve/suffix-dash.py,sha256=HMNJvB4d-PTHXDRDQTdYUKtzgirJ0LVnqqAkXxO0B4w,153
 k1lib/serve/suffix.py,sha256=UH3ITN6O2vzoha2f6v4bcQG3_Boav7VA7EC8wf8r9f8,642
-k1lib-1.3.9.4.data/data/k1lib/k1ui/256.model.state_dict.pth,sha256=Ga-UXlAJfUPNOZsvP_c1-1cfB2Hp_-oQ4ghdouX1d7g,2453826
-k1lib-1.3.9.4.data/data/k1lib/k1ui/mouseKey.pth,sha256=KULhK_gdK2Ppju9gQnv1zV2kf_A0K-vX2W7trY6DIg8,304735
-k1lib-1.3.9.4.data/data/k1lib/serve/main.html,sha256=gHFNqzE9JKb4eCwCJN-Du45jj75lDRED4Ico91T-b4g,20544
-k1lib-1.3.9.4.dist-info/LICENSE,sha256=psuy2wnTg9zacuCQ0dXfxS44iaa89aTgsNzHDzx4UGM,1049
-k1lib-1.3.9.4.dist-info/METADATA,sha256=eFUV6DHr88ryPy7v9sRDP8HgHo_mR5QjAP_7P04v01w,3890
-k1lib-1.3.9.4.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-k1lib-1.3.9.4.dist-info/top_level.txt,sha256=xxWmqZzuThnLZn49Mse6A6j41-IVduPVnQW54imcOTA,6
-k1lib-1.3.9.4.dist-info/RECORD,,
+k1lib-1.4.data/data/k1lib/k1ui/256.model.state_dict.pth,sha256=Ga-UXlAJfUPNOZsvP_c1-1cfB2Hp_-oQ4ghdouX1d7g,2453826
+k1lib-1.4.data/data/k1lib/k1ui/mouseKey.pth,sha256=KULhK_gdK2Ppju9gQnv1zV2kf_A0K-vX2W7trY6DIg8,304735
+k1lib-1.4.data/data/k1lib/serve/main.html,sha256=gHFNqzE9JKb4eCwCJN-Du45jj75lDRED4Ico91T-b4g,20544
+k1lib-1.4.dist-info/LICENSE,sha256=psuy2wnTg9zacuCQ0dXfxS44iaa89aTgsNzHDzx4UGM,1049
+k1lib-1.4.dist-info/METADATA,sha256=jz_YiNdtK-5nES6mZhILI7gduBPJusjoVGRyGEmPH48,3886
+k1lib-1.4.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+k1lib-1.4.dist-info/top_level.txt,sha256=xxWmqZzuThnLZn49Mse6A6j41-IVduPVnQW54imcOTA,6
+k1lib-1.4.dist-info/RECORD,,
```

